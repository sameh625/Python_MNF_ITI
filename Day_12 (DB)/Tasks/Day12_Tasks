---------------------------- DAY 04 ------------------------------------

-- 1. Create a function that returns the total number of orders made by a specific 
-- customer using their customer_id.

CREATE OR REPLACE FUNCTION calc_total_orders(c_customer_id int)
RETURNS decimal(10,0)
LANGUAGE plpgsql
AS $$
DECLARE
total decimal(10,0);
BEGIN
SELECT COUNT(order_id) INTO total FROM orders
WHERE orders.customer_id = c_customer_id;	
RETURN total;
END;
$$;
-- SELECT calc_total_orders(5)



-- 2. Write a function that takes a product_id and returns the category name of the product.
-- DROP FUNCTION show_category(integer)

CREATE OR REPLACE FUNCTION show_category(p_product_id int)
RETURNS VARCHAR(50)
LANGUAGE plpgsql
AS $$
DECLARE
ans VARCHAR(50);
BEGIN
SELECT category_name INTO ans FROM categories
JOIN products ON categories.category_id = products.category_id
WHERE product_id = p_product_id;
RETURN ans;
END;
$$;

-- SELECT show_category(1)



-- 3. Create a procedure that adds a new customer with their full details (name, contact name, address, etc.).
CREATE OR REPLACE PROCEDURE add_customer(c_name VARCHAR, contact_name VARCHAR, address VARCHAR, city VARCHAR, postal_code VARCHAR, country VARCHAR)
LANGUAGE plpgsql
AS $$
BEGIN
INSERT INTO customers (customer_name, contact_name, address, city, postal_code, country)
    VALUES (c_name, contact_name, address, city, postal_code, country);
END;
$$;

-- CALL add_customer(
--     'sameh',
--     'sam',
--     'st',
--     'cairo',
--     '10001',
--     'EGYPT'
-- );

-- SELECT * FROM customers WHERE country = 'EGYPT';




-- 4. Write a procedure that updates the category of a given product by its product_id.
CREATE OR REPLACE PROCEDURE update_category(p_product_id int, new_category int)
LANGUAGE plpgsql
AS $$
BEGIN
UPDATE products 
SET category_id = new_category 
WHERE product_id = p_product_id;
END;
$$;

-- SELECT * FROM products WHERE product_id = 5;
-- CALL update_category(5, 3);



-- 5. Create a trigger that prevents deleting a category if there are still products assigned to it.
CREATE OR REPLACE FUNCTION prevent_del()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
IF EXISTS(
SELECT 1 FROM order_details WHERE product_id = old.product_id)
THEN RAISE EXCEPTION 'Can not DELTE product';
END IF;
RETURN OLD;
END;
$$;

-- CREATE TRIGGER tg_prevent 
-- BEFORE DELETE ON products 
-- FOR EACH ROW
-- EXECUTE FUNCTION prevent_del()



-- 6. Create a view that displays all products with their price and a label ("Cheap", "Moderate", "Expensive") depending on the price value.

CREATE VIEW label_price AS
SELECT price , 
CASE WHEN price < 50 THEN 'Cheap'
WHEN price BETWEEN 50 AND 100 THEN 'Moderate'
WHEN price >100 THEN 'Expensive'
END AS price_level 
FROM  products;


-- SELECT * FROM label_price



-- 7. Create a view that shows each customer with the number of orders they have made.
-- DROP VIEW customers_order

CREATE VIEW customers_order AS 
SELECT COUNT(order_id) , customer_name
FROM orders o 
JOIN customers c 
ON o.customer_id = c.customer_id 
GROUP BY c.customer_name; 

-- SELECT * FROM customers_order




-- 8. Which index would you create to speed up filtering orders by customer_id
CREATE INDEX filter_order 
ON orders(customer_id);



-- 9. Create a unique index on the category_name column to prevent duplicate category names.

CREATE UNIQUE INDEX unique_cat ON categories(category_name)






-- 10. Write a transaction that inserts a new customer and a new order for that customer. If either fails, roll back.
BEGIN;
INSERT INTO customers (customer_id,customer_name, contact_name, address, city, postal_code, country)
VALUES (200,'ali', 'samir', 'Shrok St', 'Cairo', '11511', 'Egypt');

INSERT INTO orders (customer_id, order_date)
VALUES (200, '2025-09-10');

COMMIT;
ROLLBACK;
SELECT * FROM customers WHERE customer_id = 200




-- 11. Write a subquery to find all customers who have placed orders for products in a specific category (use category_id as input).
CREATE OR REPLACE FUNCTION customers_by_category(cat_id INT)
RETURNS VARCHAR(50)
LANGUAGE plpgsql
AS $$
BEGIN
SELECT customer_name FROM customers
WHERE customer_id = (
SELECT orders.customer_id
FROM orders 
JOIN order_details ON order_details.order_id = orders.order_id
JOIN products ON order_details.product_id = products.product_id
WHERE products.category_id = cat_id);
END;
$$;

SELECT customers_by_category(5)


-- 12. Create a function that calculates the total revenue generated from a specific product (based on product_id) across all orders.
-- SELECT * FROM products LIMIT 5;
-- DROP FUNCTION calc_revenue
CREATE OR REPLACE FUNCTION calc_revenue(p_product_id int)
RETURNS decimal(10,2)
LANGUAGE plpgsql
AS $$
DECLARE 
ans decimal(10,2);
BEGIN
SELECT SUM(order_details.quantity * products.price) INTO ans
FROM order_details 
JOIN products ON products.product_id = order_details.product_id
WHERE order_details.product_id = p_product_id;
RETURN ans;
END;
$$;

-- SELECT calc_revenue(2);




-- 13.Create a view that lists the top 5 customers based on the total quantity of products ordered.
-- DROP VIEW top_5_customers_by_quantity
CREATE OR REPLACE VIEW top_5 AS
SELECT c.customer_name, SUM(od.quantity) AS total_quantity
FROM customers c
JOIN orders o ON c.customer_id = o.customer_id
JOIN order_details od ON o.order_id = od.order_id
GROUP BY  c.customer_name
ORDER BY total_quantity DESC
LIMIT 5;

SELECT * FROM top_5


-- 14.Write a query using a subquery to find products that have never been ordered.

SELECT product_name
FROM products
WHERE product_id NOT IN (
    SELECT product_id
    FROM order_details
);

-- 15.Create a user role with read-only access to the customers and orders tables, and grant it to a new user then revoke its privileges .
CREATE ROLE read_only;
GRANT SELECT ON customers TO read_only;
GRANT SELECT ON orders TO read_only;

CREATE USER sameh WITH PASSWORD 'lab_04';
GRANT read_only TO sameh;

REVOKE SELECT ON ORDERS from sameh ; 
REVOKE SELECT ON customers FROM sameh;


